<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../d2l-colors/d2l-colors.html">
<link rel="import" href="./d2l-rounded-triangle.html">
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../neon-animation/neon-animation-runner-behavior.html">
<link rel="import" href="../neon-animation/animations/fade-in-animation.html">
<link rel="import" href="../neon-animation/animations/fade-out-animation.html">

<!--
`d2l-tooltip`
Polymer-based web component for a D2L tooltip

@demo demo/index.html
-->

<dom-module id="d2l-tooltip">
	<template strip-whitespace>
		<style>
			:host {
				display: block;
				position: absolute;
				outline: none;
				z-index: 1002;
				-moz-user-select: none;
				-ms-user-select: none;
				-webkit-user-select: none;
				user-select: none;
				cursor: default;
				pointer-events: none;
			}

			#tooltip {
				display: block;
				outline: none;
				font-size: 14px;
				line-height: 1;

				background-color: var(--tooltip-background-color, var(--d2l-color-ferrite));
				color: White;

				padding: 8px;
				border-radius: 5px;

				border: var(--tooltip-border);
				border-color: var(--tooltip-border-color);
				@apply --tooltip-mixin;
				opacity: 1;
			}

			.hidden {
				display: none !important;
				transition: opacity 1s ease-out;
				opacity: 0;
			}

			#triangle {
				position: absolute;
				z-index: -1; /* This triangle handles the border, and is underneath the overlay */
				--stroke-color: var(--tooltip-border-color);
			}

			#triangleOverlay {
				position: absolute;
				--fill-color: var(--tooltip-background-color);
			}
		</style>

		<div id="tooltip" class="hidden">
			<d2l-rounded-triangle id="triangle" orientation="[[ _getTriangleOrientation(position) ]]"></d2l-rounded-triangle>
			<d2l-rounded-triangle id="triangleOverlay" orientation="[[ _getTriangleOrientation(position) ]]"></d2l-rounded-triangle>
			<slot></slot>
		</div>
	</template>
	<script>
		'use strict';

		Polymer({
			is: 'd2l-tooltip',

			hostAttributes: {
				role: 'tooltip',
				tabindex: -1
			},

			behaviors: [
				Polymer.NeonAnimationRunnerBehavior,
				Polymer.IronResizableBehavior
			],

			properties: {
				for: {
					type: String,
					observer: '_findTarget'
				},

				// An object with width, height, top, and left. If the property is present and
				// is not equal to undefined, it will use the customTarget object for positioning.
				customTarget: {
					type: Object,
					observer: 'updatePosition'
				},

				position: {
					type: String,
					value: 'bottom'
				},

				offset: {
					type: Number,
					value: 8
				},

				animationDelay: {
					type: Number,
					value: 150
				},

				animationConfig: {
					type: Object,
					value: function() {
						return {
							'entry': [{
								name: 'fade-in-animation',
								node: this,
								timing: {delay: 0}
							}],
							'exit': [{
								name: 'fade-out-animation',
								node: this
							}]
						};
					}
				},

				_showing: {
					type: Boolean,
					value: false
				},

				tooltipPadding: {
					type: Number,
					value: 0
				},

				tapToggle: {
					type: Boolean,
					value: false
				},

				_tappedOn: {
					type: Boolean,
					value: false
				}
			},

			listeners: {
				'neon-animation-finish': '_onAnimationFinish',
				'iron-resize': '_onIronResize'
			},

			get target() {
				var parentNode = Polymer.dom(this).parentNode;
				var ownerRoot = Polymer.dom(this).getOwnerRoot();

				var target;
				if (this.for) {
					target = Polymer.dom(ownerRoot).querySelector('#' + this.for);
				} else if (this.customTarget !== undefined) {
					// Set to undefined because it is not used - target is a DOM node, whereas customTarget is an object
					target = undefined;
				} else {
					target = parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? ownerRoot.host : parentNode;
				}

				return target;
			},

			attached: function() {
				this._findTarget();
			},

			detached: function() {
				this._removeListeners();
			},

			show: function() {
				if (this._showing) {
					return;
				}

				if (Polymer.dom(this).textContent.trim() === '') {
					var allChildrenEmpty = true;
					var effectiveChildren = Polymer.dom(this).getEffectiveChildNodes();
					for (var i = 0; i < effectiveChildren.length; i++) {
						if (effectiveChildren[i].textContent.trim() !== '') {
							allChildrenEmpty = false;
							break;
						}
					}

					if (allChildrenEmpty) {
						return;
					}
				}

				this._showing = true;
				this.toggleClass('hidden', false, this.$.tooltip);
				this.updatePosition();

				this.animationConfig['entry'][0].timing = this.animationConfig['entry'][0].timing || {};
				this.animationConfig['entry'][0].timing.delay = this.animationDelay;
				this._animationPlaying = true;
				this.playAnimation('entry');
			},

			hide: function(event, noAnimation) {
				if (this._tappedOn || !this._showing) {
					return;
				}

				if (noAnimation) {
					this._showing = false;
					this._onAnimationFinish();
					return;
				}

				if (this._animationPlaying) {
					this.cancelAnimation();
					this._showing = false;
					this._onAnimationFinish();
					return;
				}
				this._showing = false;
				this._animationPlaying = true;
				this.playAnimation('exit');
			},

			updatePosition: function() {
				if (!this.customTarget && (!this._target || !this.offsetParent)) {
					return;
				}

				var offset = this.offset;
				var parentRect = (this.customTarget || this.offsetParent.tagName === 'BODY') ?
					{ left: 0, top: 0, right: 0, bottom: 0 } :
					this.offsetParent.getBoundingClientRect();
				var targetRect = this.customTarget ? this.customTarget : this._target.getBoundingClientRect();
				var thisRect = this.getBoundingClientRect();

				var horizontalCenterOffset = (targetRect.width - thisRect.width) / 2;
				var verticalCenterOffset = (targetRect.height - thisRect.height) / 2;
				var targetLeft = targetRect.left - parentRect.left;
				var targetTop = targetRect.top - parentRect.top;

				var triangleOffset = -15;
				var tooltipLeft, tooltipTop, triangleLeft, triangleTop;
				switch (this.position) {
					case 'top':
						tooltipLeft = targetLeft + horizontalCenterOffset;
						tooltipTop = targetTop - thisRect.height - offset;
						triangleLeft = (thisRect.width / 2) + (triangleOffset + 2);
						triangleTop = thisRect.height + (triangleOffset + 6);
						break;
					case 'bottom':
						tooltipLeft = targetLeft + horizontalCenterOffset;
						tooltipTop = targetTop + targetRect.height + offset;
						triangleLeft = (thisRect.width / 2) + (triangleOffset + 2);
						triangleTop = triangleOffset;
						break;
					case 'left':
						tooltipLeft = targetLeft - thisRect.width - offset;
						tooltipTop = targetTop + verticalCenterOffset;
						triangleLeft = thisRect.width + (triangleOffset + 6);
						triangleTop = (thisRect.height / 2) + (triangleOffset + 3);
						break;
					case 'right':
						tooltipLeft = targetLeft + targetRect.width + offset;
						tooltipTop = targetTop + verticalCenterOffset;
						triangleLeft = triangleOffset;
						triangleTop = (thisRect.height / 2) + (triangleOffset + 3);
						break;
				}

				this.style.left = tooltipLeft + 'px';
				this.style.top = tooltipTop + 'px';
				if (this.tooltipPadding) {
					this.$.tooltip.style.padding = this.tooltipPadding + 'px';
				}

				this.$.triangle.style.left = triangleLeft + 'px';
				this.$.triangle.style.top = triangleTop + 'px';
				this.$.triangleOverlay.style.left = triangleLeft + 'px';
				this.$.triangleOverlay.style.top = triangleTop + 'px';
			},

			get document() {
				if (this.ownerDocument.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
					return this.ownerDocument.host;
				}
				return this.ownerDocument;
			},

			_addListeners: function() {
				if (this._target) {
					this.listen(this._target, 'mouseenter', 'show');
					this.listen(this._target, 'focus', 'show');
					this.listen(this._target, 'mouseleave', 'hide');
					this.listen(this._target, 'blur', 'hide');
					this.listen(this._target, 'tap', '_toggle');
				}
			},

			_toggle: function() {
				if (!this.tapToggle) {
					this.hide();
					return;
				}
				this._tappedOn = !this._tappedOn;
				if (!this._tappedOn) {
					this.hide();
					this.unlisten(this.document, 'tap', '_documentClickListener');
				} else {
					this.listen(this.document, 'tap', '_documentClickListener');
					this.show();
				}
			},

			_documentClickListener: function(e) {
				if (e.target.id !== this._target.id) {
					this._tappedOn = false;
					this.hide(undefined, true);
				}
			},

			_getTriangleOrientation: function(position) {
				switch (position) {
					case 'top':
						return 'down';
					case 'bottom':
						return 'up';
					case 'left':
						return 'right';
					case 'right':
						return 'left';
				}
			},

			_findTarget: function() {
				this._removeListeners();
				this._target = this.target;
				if (this.tapToggle) {
					this._target.style.cursor = 'pointer';
				}
				this._addListeners();
			},

			_removeListeners: function() {
				if (this._target) {
					this.unlisten(this._target, 'mouseenter', 'show');
					this.unlisten(this._target, 'focus', 'show');
					this.unlisten(this._target, 'mouseleave', 'hide');
					this.unlisten(this._target, 'blur', 'hide');
					this.unlisten(this._target, 'tap', 'hide');
				}
			},

			_onAnimationFinish: function() {
				this._animationPlaying = false;
				if (!this._showing) {
					this.toggleClass('hidden', true, this.$.tooltip);
				}
			},

			_onIronResize: function() {
				this.updatePosition();
			}
		});
	</script>
</dom-module>
